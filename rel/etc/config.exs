use Mix.Config

# Application name
# app = System.get_env("APPLICATION_NAME")
# env = System.get_env("ENVIRONMENT_NAME")
# region = System.get_env("GCP_REGION")

# cond do
#   is_nil(app) ->
#     raise "APPLICATION_NAME is unset!"
#   is_nil(env) ->
#     raise "ENVIRONMENT_NAME is unset!"
#   :else ->
#     :ok
# end

# For production, we often load configuration from external
# sources, such as your system environment. For this reason,
# you won't find the :http configuration below, but set inside
# HaServer.Endpoint.init/2 when load_from_system_env is
# true. Any dynamic configuration should be done there.
#
# Don't forget to configure the url host to something meaningful,
# Phoenix uses this information when generating URLs.
#
# Finally, we also include the path to a cache manifest
# containing the digested version of static files. This
# manifest is generated by the mix phx.digest task
# which you typically run after static files are built.

host = System.get_env("HOST") || "localhost"
port = String.to_integer(System.get_env("PORT") || "4000")

config :ha_server, HaServer.Endpoint,
  load_from_system_env: true,
  http: [port: port],
  url: [host: host, port: port],
  root: "./apps/server"

config :ha_core, HaCore.Repo.EctoImpl,
  username: System.get_env("DATABASE_USER"),
  password: System.get_env("DATABASE_PASS"),
  database: System.get_env("DATABASE_NAME"),
  hostname: System.get_env("DATABASE_HOST"),
  pool_size: 10

config :exd_streams, ExdStreams.Store.RelationalStore.RecordRepo,
  username: System.get_env("DATABASE_USER"),
  password: System.get_env("DATABASE_PASS"),
  database: System.get_env("DATABASE_NAME"),
  hostname: System.get_env("DATABASE_HOST"),
  pool_size: 10

config :ha_storage, HaStorage.Hashes.HashStore.Postgres.Repo,
  username: System.get_env("DATABASE_USER"),
  password: System.get_env("DATABASE_PASS"),
  database: System.get_env("DATABASE_NAME"),
  hostname: System.get_env("DATABASE_HOST"),
  pool_size: 10
